#### LevelDB介绍

##### 跳表

跳跃表按照层进行构造,底层是一个有序的链表.高层链表充当下层链表的**快速通道**.

1. 查找过程

   查找目标元素的时候,从顶层链表开始,头元素起步.算法沿着每层链表进行搜索, 直到找到一个大于等于目标元素.或者达到当前元素的末尾.如果等于目标元素说明元素被查找到, 如果元素大于目标元素或已经到达末尾, 则退回当当前元素的上一个元素,并转入到下一层进行查找.

2. 构造方式

3. 算法评价

##### LevelDB架构



#### 索引设计

将应用中特定的类型存储了在LevelDB中。通过反射对收集到的数据进行缓存.这样可以多次便捷的访问.下述显示了levelDB中存储的分层key. 分层结构确保了索引迭代是简单的. 更新存储中的值开销并不是特别地大.

值得注意的是, 索引占用磁盘空间,而不是使用链表的指针进行处理,这个在运行时进行更新开销比较大.



缩进的处理: 当在一个父级key下存在有子key的时候.在LevelDB中,全键意味着会连接每一个层级的名称给连接起来. 每个部分使用一个空字节进行分割.

```markdown
 存储结构
 +类型名称
  	自然索引
  		+ 自然键
  		-
  	+索引名称
  		+ 索引值
  			+ 自然键
  		- 索引值
  		. 索引值
  			子索引名称
  				+ 自索引值
  					+ 数据/自然键
  					-
  	- 索引名称
```

实体数据(包括实例的自然键和数据的副本)按照+<sth>的格式存储.

匹配于特定顶层索引的所有对象的计数值按照-<sth>的后缀存储.

计数值也会存储在自然键的结尾标识符中,方便检索特定类型元素的数量.



> 例如: 给定类型Foo,使用自然键和二级索引(bar).

在存储系统中,key和value存储为两个实例.一个使用自然键key1,另一个使用名称为key2.这两个的值都是bar.

```markdown
Foo __main__ +key1   实例1的数据

Foo __main__ +key2   实例2的数据

Foo __main__ -       Foo类型计数器

Foo bar +yes +key1   实例1的key或者数据,取决于索引类型

Foo bar +yes +key2   实例2的key或者数据,取决于索引类型

Foo bar +yes -       所有yes=bar的foo计数值
```

注意到索引值都使用`+`追加在前面,尽管索引自身没有显示的结束标志符.作用是高速levelDB去寻找这个结束标记符,从而跳过索引的结尾. 通过代码和注释来看, LevelDB的全键使用实例的索引值来产生.



> 子索引存储在父级索引之后. 从上述例子上来看, 假定有个子级别的索引`child`,其父亲是`bar`. 如果实例的这个属性的value为`no`. 数据存储就会如下所示:

```markdown
Foo bar +yes -

Foo bar .yes .child +no +key1   [实例1的key或者data,与索引类型相关]

Foo bar .yes .child +no +key2   [实例2的key或者data,与索引类型相关]
```

#### 存储设计

